r_node_probe(struct hpsb_host *host, int generation)
{
	struct node_probe_parameter p;

	p.host = host;
	p.generation = generation;
	/*
	 * Do some processing of the nodes we've probed. This pulls them
	 * into the sysfs layer if needed, and can result in processing of
	 * unit-directories, or just updating the node and it's
	 * unit-directories.
	 *
	 * Run updates before probes. Usually, updates are time-critical
	 * while probes are time-consuming.
	 *
	 * Meanwhile, another bus reset may have happened. In this case we
	 * skip everything here and let the next bus scan handle it.
	 * Otherwise we may prematurely remove nodes which are still there.
	 */
	p.probe_now = false;
	if (class_for_each_device(&nodemgr_ne_class, NULL, &p, node_probe) != 0)
		return 0;

	p.probe_now = true;
	if (class_for_each_device(&nodemgr_ne_class, NULL, &p, node_probe) != 0)
		return 0;
	/*
	 * Now let's tell the bus to rescan our devices. This may seem
	 * like overhead, but the driver-model core will only scan a
	 * device for a driver when either the device is added, or when a
	 * new driver is added. A bus reset is a good reason to rescan
	 * devices that were there before.  For example, an sbp2 device
	 * may become available for login, if the host that held it was
	 * just removed.
	 */
	if (bus_rescan_devices(&ieee1394_bus_type) != 0)
		HPSB_DEBUG("bus_rescan_devices had an error");

	return 1;
}

static int remove_nodes_in_limbo(struct device *dev, void *data)
{
	struct node_entry *ne;

	if (dev->bus != &ieee1394_bus_type)
		return 0;

	ne = container_of(dev, struct node_entry, device);
	if (ne->in_limbo)
		nodemgr_remove_ne(ne);

	return 0;
}

static void nodemgr_remove_nodes_in_limbo(struct hpsb_host *host)
{
	device_for_each_child(&host->device, NULL, remove_nodes_in_limbo);
}

static int nodemgr_send_resume_packet(struct hpsb_host *host)
{
	struct hpsb_packet *packet;
	int error = -ENOMEM;

	packet = hpsb_make_phypacket(host,
			EXTPHYPACKET_TYPE_RESUME |
			NODEID_TO_NODE(host->node_id) << PHYPACKET_PORT_SHIFT);
	if (packet) {
		packet->no_waiter = 1;
		packet->generation = get_hpsb_generation(host);
		error = hpsb_send_packet(packet);
	}
	if (error)
		HPSB_WARN("fw-host%d: Failed to broadcast resume packet",
			  host->id);
	return error;
}

/* Perform a few high-level IRM responsibilities. */
static int nodemgr_do_irm_duties(struct hpsb_host *host, int cycles)
{
	quadlet_t bc;

	/* if irm_id == -1 then there is no IRM on this bus */
	if (!host->is_irm || host->irm_id == (nodeid_t)-1)
		return 1;

	/* We are a 1394a-2000 compliant IRM. Set the validity bit. */
	host->csr.broadcast_channel |= 0x40000000;

	/* If there is no bus manager then we should set the root node's
	 * force_root bit to promote bus stability per the 1394
	 * spec. (8.4.2.6) */
	if (host->busmgr_id == 0xffff && host->node_count > 1)
	{
		u16 root_node = host->node_count - 1;

		/* get cycle master capability flag from root node */
		if (host->is_cycmst ||
		    (!hpsb_read(host, LOCAL_BUS | root_node, get_hpsb_generation(host),
				(CSR_REGISTER_BASE + CSR_CONFIG_ROM + 2 * sizeof(quadlet_t)),
				&bc, sizeof(quadlet_t)) &&
		     be32_to_cpu(bc) & 1 << CSR_CMC_SHIFT))
			hpsb_send_phy_config(host, root_node, -1);
		else {
			HPSB_DEBUG("The root node is not cycle master capable; "
				   "selecting a new root node and resetting...");

			if (cycles >= 5) {
				/* Oh screw it! Just leave the bus as it is */
				HPSB_DEBUG("Stopping reset loop for IRM sanity");
				return 1;
			}

			hpsb_send_phy_config(host, NODEID_TO_NODE(host->node_id), -1);
			hpsb_reset_bus(host, LONG_RESET_FORCE_ROOT);

			return 0;
		}
	}

	/* Some devices suspend their ports while being connected to an inactive
	 * host adapter, i.e. if connected before the low-level driver is
	 * loaded.  They become visible either when physically unplugged and
	 * replugged, or when receiving a resume packet.  Send one once. */
	if (!host->resume_packet_sent && !nodemgr_send_resume_packet(host))
		host->resume_packet_sent = 1;

	return 1;
}

/* We need to ensure that if we are not the IRM, that the IRM node is capable of
 * everything we can do, otherwise issue a bus reset and try to become the IRM
 * ourselves. */
static int nodemgr_check_irm_capability(struct hpsb_host *host, int cycles)
{
	quadlet_t bc;
	int status;

	if (hpsb_disable_irm || host->is_irm)
		return 1;

	status = hpsb_read(host, LOCAL_BUS | (host->irm_id),
			   get_hpsb_generation(host),
			   (CSR_REGISTER_BASE | CSR_BROADCAST_CHANNEL),
			   &bc, sizeof(quadlet_t));

	if (status < 0 || !(be32_to_cpu(bc) & 0x80000000)) {
		/* The current irm node does not have a valid BROADCAST_CHANNEL
		 * register and we do, so reset the bus with force_root set */
		HPSB_DEBUG("Current remote IRM is not 1394a-2000 compliant, resetting...");

		if (cycles >= 5) {
			/* Oh screw it! Just leave the bus as it is */
			HPSB_DEBUG("Stopping reset loop for IRM sanity");
			return 1;
		}

		hpsb_send_phy_config(host, NODEID_TO_NODE(host->node_id), -1);
		hpsb_reset_bus(host, LONG_RESET_FORCE_ROOT);

		return 0;
	}

	return 1;
}

static int nodemgr_host_thread(void *data)
{
	struct hpsb_host *host = data;
	unsigned int g, generation = 0;
	int i, reset_cycles = 0;

	set_freezable();
	/* Setup our device-model entries */
	nodemgr_create_host_dev_files(host);

	for (;;) {
		/* Sleep until next bus reset */
		set_current_state(TASK_INTERRUPTIBLE);
		if (get_hpsb_generation(host) == generation &&
		    !kthread_should_stop())
			schedule();
		__set_current_state(TASK_RUNNING);

		/* Thread may have been woken up to freeze or to exit */
		if (try_to_freeze())
			continue;
		if (kthread_should_stop())
			goto exit;

		/* Pause for 1/4 second in 1/16 second intervals,
		 * to make sure things settle down. */
		g = get_hpsb_generation(host);
		for (i = 0; i < 4 ; i++) {
			msleep_interruptible(63);
			try_to_freeze();
			if (kthread_should_stop())
				goto exit;

			/* Now get the generation in which the node ID's we collect
			 * are valid.  During the bus scan we will use this generation
			 * for the read transactions, so that if another reset occurs
			 * during the scan the transactions will fail instead of
			 * returning bogus data. */
			generation = get_hpsb_generation(host);

			/* If we get a reset before we are done waiting, then
			 * start the waiting over again */
			if (generation != g)
				g = generation, i = 0;
		}

		if (!nodemgr_check_irm_capability(host, reset_cycles) ||
		    !nodemgr_do_irm_duties(host, reset_cycles)) {
			reset_cycles++;
			continue;
		}
		reset_cycles = 0;

		/* Scan our nodes to get the bus options and create node
		 * entries. This does not do the sysfs stuff, since that
		 * would trigger uevents and such, which is a bad idea at
		 * this point. */
		nodemgr_node_scan(host, generation);

		/* This actually does the full probe, with sysfs
		 * registration. */
		if (!nodemgr_node_probe(host, generation))
			continue;

		/* Update some of our sysfs symlinks */
		nodemgr_update_host_dev_links(host);

		/* Sleep 3 seconds */
		for (i = 3000/200; i; i--) {
			msleep_interruptible(200);
			try_to_freeze();
			if (kthread_should_stop())
				goto exit;

			if (generation != get_hpsb_generation(host))
				break;
		}
		/* Remove nodes which are gone, unless a bus reset happened */
		if (!i)
			nodemgr_remove_nodes_in_limbo(host);
	}
exit:
	HPSB_VERBOSE("NodeMgr: Exiting thread");
	return 0;
}

struct per_host_parameter {
	void *data;
	int (*cb)(struct hpsb_host *, void *);
};

static int per_host(struct device *dev, void *data)
{
	struct hpsb_host *host;
	struct per_host_parameter *p = data;

	host = container_of(dev, struct hpsb_host, host_dev);
	return p->cb(host, p->data);
}

/**
 * nodemgr_for_each_host - call a function for each IEEE 1394 host
 * @data: an address to supply to the callback
 * @cb: function to call for each host
 *
 * Iterate the hosts, calling a given function with supplied data for each host.
 * If the callback fails on a host, i.e. if it returns a non-zero value, the
 * iteration is stopped.
 *
 * Return value: 0 on success, non-zero on failure (same as returned by last run
 * of the callback).
 */
int nodemgr_for_each_host(void *data, int (*cb)(struct hpsb_host *, void *))
{
	struct per_host_parameter p;

	p.cb = cb;
	p.data = data;
	return class_for_each_device(&hpsb_host_class, NULL, &p, per_host);
}

/* The following two convenience functions use a struct node_entry
 * for addressing a node on the bus.  They are intended for use by any
 * process context, not just the nodemgr thread, so we need to be a
 * little careful when reading out the node ID and generation.  The
 * thing that can go wrong is that we get the node ID, then a bus
 * reset occurs, and then we read the generation.  The node ID is
 * possibly invalid, but the generation is current, and we end up
 * sending a packet to a the wrong node.
 *
 * The solution is to make sure we read the generation first, so that
 * if a reset occurs in the process, we end up with a stale generation
 * and the transactions will fail instead of silently using wrong node
 * ID's.
 */

/**
 * hpsb_node_fill_packet - fill some destination information into a packet
 * @ne: destination node
 * @packet: packet to fill in
 *
 * This will fill in the given, pre-initialised hpsb_packet with the current
 * information from the node entry (host, node ID, bus generation number).
 */
void hpsb_node_fill_packet(struct node_entry *ne, struct hpsb_packet *packet)
{
	packet->host = ne->host;
	packet->generation = ne->generation;
	smp_rmb();
	packet->node_id = ne->nodeid;
}

int hpsb_node_write(struct node_entry *ne, u64 addr,
		    quadlet_t *buffer, size_t length)
{
	unsigned int generation = ne->generation;

	smp_rmb();
	return hpsb_write(ne->host, ne->nodeid, generation,
			  addr, buffer, length);
}

static void nodemgr_add_host(struct hpsb_host *host)
{
	struct host_info *hi;

	hi = hpsb_create_hostinfo(&nodemgr_highlevel, host, sizeof(*hi));
	if (!hi) {
		HPSB_ERR("NodeMgr: out of memory in add host");
		return;
	}
	hi->host = host;
	hi->thread = kthread_run(nodemgr_host_thread, host, "knodemgrd_%d",
				 host->id);
	if (IS_ERR(hi->thread)) {
		HPSB_ERR("NodeMgr: cannot start thread for host %d", host->id);
		hpsb_destroy_hostinfo(&nodemgr_highlevel, host);
	}
}

static void nodemgr_host_reset(struct hpsb_host *host)
{
	struct host_info *hi = hpsb_get_hostinfo(&nodemgr_highlevel, host);

	if (hi) {
		HPSB_VERBOSE("NodeMgr: Processing reset for host %d", host->id);
		wake_up_process(hi->thread);
	}
}

static void nodemgr_remove_host(struct hpsb_host *host)
{
	struct host_info *hi = hpsb_get_hostinfo(&nodemgr_highlevel, host);

	if (hi) {
		kthread_stop(hi->thread);
		nodemgr_remove_host_dev(&host->device);
	}
}

static struct hpsb_highlevel nodemgr_highlevel = {
	.name =		"Node manager",
	.add_host =	nodemgr_add_host,
	.host_reset =	nodemgr_host_reset,
	.remove_host =	nodemgr_remove_host,
};

int init_ieee1394_nodemgr(void)
{
	int error;

	error = class_register(&nodemgr_ne_class);
	if (error)
		goto fail_ne;
	error = class_register(&nodemgr_ud_class);
	if (error)
		goto fail_ud;
	error = driver_register(&nodemgr_mid_layer_driver);
	if (error)
		goto fail_ml;
	/* This driver is not used if nodemgr is off (disable_nodemgr=1). */
	nodemgr_dev_template_host.driver = &nodemgr_mid_layer_driver;

	hpsb_register_highlevel(&nodemgr_highlevel);
	return 0;

fail_ml:
	class_unregister(&nodemgr_ud_class);
fail_ud:
	class_unregister(&nodemgr_ne_class);
fail_ne:
	return error;
}

void cleanup_ieee1394_nodemgr(void)
{
	hpsb_unregister_highlevel(&nodemgr_highlevel);
	driver_unregister(&nodemgr_mid_layer_driver);
	class_unregister(&nodemgr_ud_class);
	class_unregister(&nodemgr_ne_class);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       INDX( 	                 (   а   У      Т ╬ k л   л        ╔7     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
БТ pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7    Т Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a Т e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јТ ј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7    Т Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e     Т               h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~ЇТ        ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     h R     ѓ7     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                     Зм;јл8B
Б╬pџм;јлј§уж~Їл       ч               M a k e f i l e                                   Т _SPI_AT25 is not set
 # CONFIG_SPI_SPIDEV is not set
 # CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -848,15 +941,20 @@ CONFIG_SSB_POSSIBLE=y
 #
 # CONFIG_MFD_CORE is not set
 # CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
 # CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
 # CONFIG_MFD_WM8400 is not set
 # CONFIG_MFD_WM8350_I2C is not set
-
-#
-# Multimedia devices
-#
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
 
 #
 # Multimedia core support
@@ -873,15 +971,24 @@ CONFIG_VIDEO_MEDIA=y
 #
 # CONFIG_MEDIA_ATTACH is not set
 CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
 CONFIG_VIDEO_V4L2=y
 CONFIG_VIDEO_V4L1=y
 CONFIG_VIDEO_CAPTURE_DRIVERS=y
@@ -912,6 +1019,11 @@ CONFIG_VIDEO_CAPTURE_DRIVERS=y
 # CONFIG_VIDEO_VP27SMPX is not set
 
 #
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
 # Video decoders
 #
 # CONFIG_VIDEO_BT819 is not set
@@ -919,13 +1031,13 @@ CONFIG_VIDEO_CAPTURE_DRIVERS=y
 # CONFIG_VIDEO_BT866 is not set
 # CONFIG_VIDEO_KS0127 is not set
 # CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
 # CONFIG_VIDEO_TCM825X is not set
 # CONFIG_VIDEO_SAA7110 is not set
-# CONFIG_VIDEO_SAA7111 is not set
-# CONFIG_VIDEO_SAA7114 is not set
 # CONFIG_VIDEO_SAA711X is not set
 # CONFIG_VIDEO_SAA717X is not set
 # CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
 # CONFIG_VIDEO_TVP5150 is not set
 # CONFIG_VIDEO_VPX3220 is not set
 
@@ -946,6 +1058,8 @@ CONFIG_VIDEO_CAPTURE_DRIVERS=y
 # CONFIG_VIDEO_SAA7185 is not set
 # CONFIG_VIDEO_ADV7170 is not set
 # CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
 
 #
 # Video improvement chips
@@ -966,9 +1080,10 @@ CONFIG_VIDEO_MXC_IPU_CAMERA=y
 # CONFIG_MXC_CAMERA_MICRON111 is not set
 CONFIG_MXC_CAMERA_OV2640=m
 # CONFIG_MXC_CAMERA_OV3640 is not set
-CONFIG_MXC_TVIN_ADV7180=m
+# CONFIG_MXC_TVIN_ADV7180 is not set
 CONFIG_MXC_IPU_PRP_VF_SDC=m
 CONFIG_MXC_IPU_PRP_ENC=m
+CONFIG_MXC_IPU_CSI_ENC=m
 CONFIG_VIDEO_MXC_OUTPUT=y
 CONFIG_VIDEO_MXC_IPU_OUTPUT=y
 # CONFIG_VIDEO_MXC_IPUV1_WVGA_OUTPUT is not set
@@ -980,15 +1095,20 @@ CONFIG_VIDEO_MXC_IPU_OUTPUT=y
 # CONFIG_SOC_CAMERA is not set
 CONFIG_V4L_USB_DRIVERS=y
 # CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
 CONFIG_USB_GSPCA=m
 # CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
 # CONFIG_USB_GSPCA_CONEX is not set
 # CONFIG_USB_GSK_CMD_LED_OFF		0x11

/* Mode control */
#define LK_MODE_DOWN		0x80
#define LK_MODE_AUTODOWN	0x82
#define LK_MODE_UPDOWN		0x86
#define LK_CMD_SET_MODE(mode,div)	((mode) | ((div) << 3))

/* Misc commands */
#define LK_CMD_ENABLE_KEYCLICK	0x1b
#define LK_CMD_DISABLE_KEYCLICK	0x99
#define LK_CMD_DISABLE_BELL	0xa1
#define LK_CMD_SOUND_BELL	0xa7
#define LK_CMD_ENABLE_BELL	0x23
#define LK_CMD_DISABLE_CTRCLICK	0xb9
#define LK_CMD_ENABLE_CTRCLICK	0xbb
#define LK_CMD_SET_DEFAULTS	0xd3
#define LK_CMD_POWERCYCLE_RESET	0xfd
#define LK_CMD_ENABLE_LK401	0xe9
#define LK_CMD_REQUEST_ID	0xab

/* Misc responses from keyboard */
#define LK_STUCK_KEY		0x3d
#define LK_SELFTEST_FAILED	0x3e
#define LK_ALL_KEYS_UP		0xb3
#define LK_METRONOME		0xb4
#define LK_OUTPUT_ERROR		0xb5
#define LK_INPUT_ERROR		0xb6
#define LK_KBD_LOCKED		0xb7
#define LK_KBD_TEST_MODE_ACK	0xb8
#define LK_PREFIX_KEY_DOWN	0xb9
#define LK_MODE_CHANGE_ACK	0xba
#define LK_RESPONSE_RESERVED	0xbb

#define LK_NUM_KEYCODES		256
#define LK_NUM_IGNORE_BYTES	6
typedef u_int16_t lk_keycode_t;



static lk_keycode_t lkkbd_keycode[LK_NUM_KEYCODES] = {
	[0x56] = KEY_F1,
	[0x57] = KEY_F2,
	[0x58] = KEY_F3,
	[0x59] = KEY_F4,
	[0x5a] = KEY_F5,
	[0x64] = KEY_F6,
	[0x65] = KEY_F7,
	[0x66] = KEY_F8,
	[0x67] = KEY_F9,
	[0x68] = KEY_F10,
	[0x71] = KEY_F11,
	[0x72] = KEY_F12,
	[0x73] = KEY_F13,
	[0x74] = KEY_F14,
	[0x7c] = KEY_F15,
	[0x7d] = KEY_F16,
	[0x80] = KEY_F17,
	[0x81] = KEY_F18,
	[0x82] = KEY_F19,
	[0x83] = KEY_F20,
	[0x8a] = KEY_FIND,
	[0x8b] = KEY_INSERT,
	[0x8c] = KEY_DELETE,
	[0x8d] = KEY_SELECT,
	[0x8e] = KEY_PAGEUP,
	[0x8f] = KEY_PAGEDOWN,
	[0x92] = KEY_KP0,
	[0x94] = KEY_KPDOT,
	[0x95] = KEY_KPENTER,
	[0x96] = KEY_KP1,
	[0x97] = KEY_KP2,
	[0x98] = KEY_KP3,
	[0x99] = KEY_KP4,
	[0x9a] = KEY_KP5,
	[0x9b] = KEY_KP6,
	[0x9c] = KEY_KPCOMMA,
	[0x9d] = KEY_KP7,
	[0x9e] = KEY_KP8,
	[0x9f] = KEY_KP9,
	[0xa0] = KEY_KPMINUS,
	[0xa1] = KEY_PROG1,
	[0xa2] = KEY_PROG2,
	[0xa3] = KEY_PROG3,
	[0xa4] = KEY_PROG4,
	[0xa7] = KEY_LEFT,
	[0xa8] = KEY_RIGHT,
	[0xa9] = KEY_DOWN,
	[0xaa] = KEY_UP,
	[0xab] = KEY_RIGHTSHIFT,
	[0xac] = KEY_LEFTALT,
	[0xad] = KEY_COMPOSE, /* Right Compose, that is. */
	[0xae] = KEY_LEFTSHIFT, /* Same as KEY_RIGHTSHIFT on LK201 */
	[0xaf] = KEY_LEFTCTRL,
	[0xb0] = KEY_CAPSLOCK,
	[0xb1] = KEY_COMPOSE, /* Left Compose, that is. */
	[0xb2] = KEY_RIGHTALT,
	[0xbc] = KEY_BACKSPACE,
	[0xbd] = KEY_ENTER,
	[0xbe] = KEY_TAB,
	[0xbf] = KEY_ESC,
	[0xc0] = KEY_1,
	[0xc1] = KEY_Q,
	[0xc2] = KEY_A,
	[0xc3] = KEY_Z,
	[0xc5] = KEY_2,
	[0xc6] = KEY_W,
	[0xc7] = KEY_S,
	[0xc8] = KEY_X,
	[0xc9] = KEY_102ND,
	[0xcb] = KEY_3,
	[0xcc] = KEY_E,
	[0xcd] = KEY_D,
	[0xce] = KEY_C,
	[0xd0] = KEY_4,
	[0xd1] = KEY_R,
	[0xd2] = KEY_F,
	[0xd3] = KEY_V,
	[0xd4] = KEY_SPACE,
	[0xd6] = KEY_5,
	[0xd7] = KEY_T,
	[0xd8] = KEY_G,
	[0xd9] = KEY_B,
	[0xdb] = KEY_6,
	[0xdc] = KEY_Y,
	[0xdd] = KEY_H,
	[0xde] = KEY_N,
	[0xe0] = KEY_7,
	[0xe1] = KEY_U,
	[0xe2] = KEY_J,
	[0xe3] = KEY_M,
	[0xe5] = KEY_8,
	[0xe6] = KEY_I,
	[0xe7] = KEY_K,
	[0xe8] = KEY_COMMA,
	[0xea] = KEY_9,
	[0xeb] = KEY_O,
	[0xec] = KEY_L,
	[0xed] = KEY_DOT,
	[0xef] = KEY_0,
	[0xf0] = KEY_P,
	[0xf2] = KEY_SEMICOLON,
	[0xf3] = KEY_SLASH,
	[0xf5] = KEY_EQUAL,
	[0xf6] = KEY_RIGHTBRACE,
	[0xf7] = KEY_BACKSLASH,
	[0xf9] = KEY_MINUS,
	[0xfa] = KEY_LEFTBRACE,
	[0xfb] = KEY_APOSTROPHE,
};

#define CHECK_LED(LK, VAR_ON, VAR_OFF, LED, BITS) do {		\
	if (test_bit (LED, (LK)->dev->led))			\
		VAR_ON |= BITS;					\
	else							\
		VAR_OFF |= BITS;				\
	} while (0)

/*
 * Per-keyboard data
 */
struct lkkbd {
	lk_keycode_t keycode[LK_NUM_KEYCODES];
	int ignore_bytes;
	unsigned char id[LK_NUM_IGNORE_BYTES];
	struct input_dev *dev;
	struct serio *serio;
	struct work_struct tq;
	char name[64];
	char phys[32];
	char type;
	int bell_volume;
	int keyclick_volume;
	int ctrlclick_volume;
};

#ifdef LKKBD_DEBUG
/*
 * Responses from the keyboard and mapping back to their names.
 */
static struct {
	unsigned char value;
	unsigned char *name;
} lk_response[] = {
#define RESPONSE(x) { .value = (x), .name = #x, }
	RESPONSE (LK_STUCK_KEY),
	RESPONSE (LK_SELFTEST_FAILED),
	RESPONSE (LK_ALL_KEYS_UP),
	RESPONSE (LK_METRONOME),
	RESPONSE (LK_OUTPUT_ERROR),
	RESPONSE (LK_INPUT_ERROR),
	RESPONSE (LK_KBD_LOCKED),
	RESPONSE (LK_KBD_TEST_MODE_ACK),
	RESPONSE (LK_PREFIX_KEY_DOWN),
	RESPONSE (LK_MODE_CHANGE_ACK),
	RESPONSE (LK_RESPONSE_RESERVED),
#undef RESPONSE
};

static unsigned char *
response_name (unsigned char value)
{
	int i;

	for (i = 0; i < ARRAY_SIZE (lk_response); i++)
		if (lk_response[i].value == value)
			return lk_response[i].name;

	return "<unknown>";
}
#endif /* LKKBD_DEBUG */

/*
 * Calculate volume parameter byte for a given volume.
 */
static unsigned char
volume_to_hw (int volume_percent)
{
	unsigned char ret = 0;

	if (volume_percent < 0)
		volume_percent = 0;
	if (volume_percent > 100)
		volume_percent = 100;

	if (volume_percent >= 0)
		ret = 7;
	if (volume_percent >= 13)	/* 12.5 */
		ret = 6;
	if (volume_percent >= 25)
		ret = 5;
	if (volume_percent >= 38)	/* 37.5 */
		ret = 4;
	if (volume_percent >= 50)
		ret = 3;
	if (volume_percent >= 63)	/* 62.5 */
		ret = 2;		/* This is the default volume */
	if (volume_percent >= 75)
		ret = 1;
	if (volume_percent >= 88)	/* 87.5 */
		ret = 0;

	ret |= 0x80;

	return ret;
}

static void
lkkbd_detection_done (struct lkkbd *lk)
{
	int i;

	/*
	 * Reset setting for Compose key. Let Compose be KEY_COMPOSE.
	 */
	lk->keycode[0xb1] = KEY_COMPOSE;

	/*
	 * Print keyboard name and modify Compose=Alt on user's request.
	 */
	switch (lk->id[4]) {
		case 1:
			strlcpy (lk->name, "DEC LK201 keyboard",
				 sizeof (lk->name));

			if (lk201_compose_is_alt)
				lk->keycode[0xb1] = KEY_LEFTALT;
			break;

		case 2:
			strlcpy (lk->name, "DEC LK401 keyboard",
				 sizeof (lk->name));
			break;

		default:
			strlcpy (lk->name, "Unknown DEC keyboard",
				 sizeof (lk->name));
			printk (KERN_ERR "lkkbd: keyboard on %s is unknown, "
					"please report to Jan-Benedict Glaw "
					"<jbglaw@lug-owl.de>\n", lk->phys);
			printk (KERN_ERR "lkkbd: keyboard ID'ed as:");
			for (i = 0; i < LK_NUM_IGNORE_BYTES; i++)
				printk (" 0x%02x", lk->id[i]);
			printk ("\n");
			break;
	}
	printk (KERN_INFO "lkkbd: keyboard on %s identified as: %s\n",
			lk->phys, lk->name);

	/*
	 * Report errors during keyboard boot-up.
	 */
	switch (lk->id[2]) {
		case 0x00:
			/* All okay */
			break;

		case LK_STUCK_KEY:
			printk (KERN_ERR "lkkbd: Stuck key on keyboard at "
					"%s\n", lk->phys);
			break;

		case LK_SELFTEST_FAILED:
			printk (KERN_ERR "lkkbd: Selftest failed on keyboard "
					"at %s, keyboard may not work "
					"properly\n", lk->phys);
			break;

		default:
			printk (KERN_ERR "lkkbd: Unknown error %02x on "
					"keyboard at %s\n", lk->id[2],
					lk->phys);
			break;
	}

	/*
	 * Try to hint user if there's a stuck key.
	 */
	if (lk->id[2] == LK_STUCK_KEY && lk->id[3] != 0)
		printk (KERN_ERR "Scancode of stuck key is 0x%02x, keycode "
				"is 0x%04x\n", lk->id[3],
				lk->keycode[lk->id[3]]);

	return;
}

/*
 * lkkbd_interrupt() is called by the low level driver when a character
 * is received.
 */
static irqreturn_t
lkkbd_interrupt (struct serio *serio, unsigned char data, unsigned int flags)
{
	struct lkkbd *lk = serio_get_drvdata (serio);
	int i;

	DBG (KERN_INFO "Got byte 0x%02x\n", data);

	if (lk->ignore_bytes > 0) {
		DBG (KERN_INFO "Ignoring a byte on %s\n", lk->name);
		lk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;

		if (lk->ignore_bytes == 0)
			lkkbd_detection_done (lk);

		return IRQ_HANDLED;
	}

	switch (data) {
		case LK_ALL_KEYS_UP:
			for (i = 0; i < ARRAY_SIZE (lkkbd_keycode); i++)
				if (lk->keycode[i] != KEY_RESERVED)
					input_report_key (lk->dev, lk->keycode[i], 0);
			input_sync (lk->dev);
			break;

		case 0x01:
			DBG (KERN_INFO "Got 0x01, scheduling re-initialization\n");
			lk->ignore_bytes = LK_NUM_IGNORE_BYTES;
			lk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;
			schedule_work (&lk->tq);
			break;

		case LK_METRONOME:
		case LK_OUTPUT_ERROR:
		case LK_INPUT_ERROR:
		case LK_KBD_LOCKED:
		case LK_KBD_TEST_MODE_ACK:
		case LK_PREFIX_KEY_DOWN:
		case LK_MODE_CHANGE_ACK:
		case LK_RESPONSE_RESERVED:
			DBG (KERN_INFO "Got %s and don't know how to handle...\n",
					response_name (data));
			break;

		default:
			if (lk->keycode[data] != KEY_RESERVED) {
				if (!test_bit (lk->keycode[data], lk->dev->key))
					input_report_key (lk->dev, lk->keycode[data], 1);
				else
					input_report_key (lk->dev, lk->keycode[data], 0);
				input_sync (lk->dev);
                        } else
                                printk (KERN_WARNING "%s: Unknown key with "
						"scancode 0x%02x on %s.\n",
						__FILE__, data, lk->name);
	}

	return IRQ_HANDLED;
}

/*
 * lkkbd_event() handles events from the input module.
 */
static int
lkkbd_event (struct input_dev *dev, unsigned int type, unsigned int code,
		int value)
{
	struct lkkbd *lk = input_get_drvdata (dev);
	unsigned char leds_on = 0;
	unsigned char leds_off = 0;

	switch (type) {
		case EV_LED:
			CHECK_LED (lk, leds_on, leds_off, LED_CAPSL, LK_LED_SHIFTLOCK);
			CHECK_LED (lk, leds_on, leds_off, LED_COMPOSE, LK_LED_COMPOSE);
			CHECK_LED (lk, leds_on, leds_off, LED_SCROLLL, LK_LED_SCROLLLOCK);
			CHECK_LED (lk, leds_on, leds_off, LED_SLEEP, LK_LED_WAIT);
			if (leds_on != 0) {
				lk->serio->write (lk->serio, LK_CMD_LED_ON);
				lk->serio->write (lk->serio, leds_on);
			}
			if (leds_off != 0) {
				lk->serio->write (lk->serio, LK_CMD_LED_OFF);
				lk->serio->write (lk->serio, leds_off);
			}
			return 0;

		case EV_SND:
			switch (code) {
				case SND_CLICK:
					if (value == 0) {
						DBG ("%s: Deactivating key clicks\n", __func__);
						lk->serio->write (lk->serio, LK_CMD_DISABLE_KEYCLICK);
						lk->serio->write (lk->serio, LK_CMD_DISABLE_CTRCLICK);
					} else {
						DBG ("%s: Activating key clicks\n", __func__);
						lk->serio->write (lk->serio, LK_CMD_ENABLE_KEYCLICK);
						lk->serio->write (lk->serio, volume_to_hw (lk->keyclick_volume));
						lk->serio->write (lk->serio, LK_CMD_ENABLE_CTRCLICK);
						lk->serio->write (lk->serio, volume_to_hw (lk->ctrlclick_volume));
					}
					return 0;

				case SND_BELL:
					if (value != 0)
						lk->serio->write (lk->serio, LK_CMD_SOUND_BELL);

					return 0;
			}
			break;

		default:
			printk (KERN_ERR "%s (): Got unknown type %d, code %d, value %d\n",
					__func__, type, code, value);
	}

	return -1;
}

/*
 * lkkbd_reinit() sets leds and beeps to a state the computer remembers they
 * were in.
 */
static void
lkkbd_reinit (struct work_struct *work)
{
	struct lkkbd *lk = container_of(work, struct lkkbd, tq);
	int division;
	unsigned char leds_on = 0;
	unsigned char leds_off = 0;

	/* Ask for ID */
	lk->serio->write (lk->serio, LK_CMD_REQUEST_ID);

	/* Reset parameters */
	lk->serio->write (lk->serio, LK_CMD_SET_DEFAULTS);

	/* Set LEDs */
	CHECK_LED (lk, leds_on, leds_off, LED_CAPSL, LK_LED_SHIFTLOCK);
	CHECK_LED (lk, leds_on, leds_off, LED_COMPOSE, LK_LED_COMPOSE);
	CHECK_LED (lk, leds_on, leds_off, LED_SCROLLL, LK_LED_SCROLLLOCK);
	CHECK_LED (lk, leds_on, leds_off, LED_SLEEP, LK_LED_WAIT);
	if (leds_on != 0) {
		lk->serio->write (lk->serio, LK_CMD_LED_ON);
		lk->serio->write (lk->serio, leds_on);
	}
	if (leds_off != 0) {
		lk->serio->write (lk->serio, LK_CMD_LED_OFF);
		lk->serio->write (lk->serio, leds_off);
	}

	/*
	 * Try to activate extended LK401 mode. This command will
	 * only work with a LK401 keyboard and grants access to
	 * LAlt, RAlt, RCompose and RShift.
	 */
	lk->serio->write (lk->serio, LK_CMD_ENABLE_LK401);

	/* Set all keys to UPDOWN mode */
	for (division = 1; division <= 14; division++)
		lk->serio