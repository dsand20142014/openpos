 be16_to_cpu(txre->bytecnt);
			pi->txr_tail = (pi->txr_tail+1) & (MPSC_TXR_ENTRIES-1);

			/* If no more data to tx, fall out of loop */
			if (pi->txr_head == pi->txr_tail)
				break;

			txre = (struct mpsc_tx_desc *)(pi->txr
					+ (pi->txr_tail * MPSC_TXRE_SIZE));
			dma_cache_sync(pi->port.dev, (void *)txre,
					MPSC_TXRE_SIZE, DMA_FROM_DEVICE);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
			if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
				invalidate_dcache_range((ulong)txre,
						(ulong)txre + MPSC_TXRE_SIZE);
#endif
		}

		mpsc_copy_tx_data(pi);
		mpsc_sdma_start_tx(pi);	/* start next desc if ready */
	}

	spin_unlock_irqrestore(&pi->tx_lock, iflags);
	return rc;
}

/*
 * This is the driver's interrupt handler.  To avoid a race, we first clear
 * the interrupt, then handle any completed Rx/Tx descriptors.  When done
 * handling those descriptors, we restart the Rx/Tx engines if they're stopped.
 */
static irqreturn_t mpsc_sdma_intr(int irq, void *dev_id)
{
	struct mpsc_port_info *pi = dev_id;
	ulong iflags;
	int rc = IRQ_NONE;

	pr_debug("mpsc_sdma_intr[%d]: SDMA Interrupt Received\n",pi->port.line);

	spin_lock_irqsave(&pi->port.lock, iflags);
	mpsc_sdma_intr_ack(pi);
	if (mpsc_rx_intr(pi))
		rc = IRQ_HANDLED;
	if (mpsc_tx_intr(pi))
		rc = IRQ_HANDLED;
	spin_unlock_irqrestore(&pi->port.lock, iflags);

	pr_debug("mpsc_sdma_intr[%d]: SDMA Interrupt Handled\n", pi->port.line);
	return rc;
}

/*
 ******************************************************************************
 *
 * serial_core.c Interface routines
 *
 ******************************************************************************
 */
static uint mpsc_tx_empty(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	ulong iflags;
	uint rc;

	spin_lock_irqsave(&pi->port.lock, iflags);
	rc = mpsc_sdma_tx_active(pi) ? 0 : TIOCSER_TEMT;
	spin_unlock_irqrestore(&pi->port.lock, iflags);

	return rc;
}

static void mpsc_set_mctrl(struct uart_port *port, uint mctrl)
{
	/* Have no way to set modem control lines AFAICT */
}

static uint mpsc_get_mctrl(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	u32 mflags, status;

	status = (pi->mirror_regs) ? pi->MPSC_CHR_10_m
		: readl(pi->mpsc_base + MPSC_CHR_10);

	mflags = 0;
	if (status & 0x1)
		mflags |= TIOCM_CTS;
	if (status & 0x2)
		mflags |= TIOCM_CAR;

	return mflags | TIOCM_DSR;	/* No way to tell if DSR asserted */
}

static void mpsc_stop_tx(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;

	pr_debug("mpsc_stop_tx[%d]\n", port->line);

	mpsc_freeze(pi);
}

static void mpsc_start_tx(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	unsigned long iflags;

	spin_lock_irqsave(&pi->tx_lock, iflags);

	mpsc_unfreeze(pi);
	mpsc_copy_tx_data(pi);
	mpsc_sdma_start_tx(pi);

	spin_unlock_irqrestore(&pi->tx_lock, iflags);

	pr_debug("mpsc_start_tx[%d]\n", port->line);
}

static void mpsc_start_rx(struct mpsc_port_info *pi)
{
	pr_debug("mpsc_start_rx[%d]: Starting...\n", pi->port.line);

	if (pi->rcv_data) {
		mpsc_enter_hunt(pi);
		mpsc_sdma_cmd(pi, SDMA_SDCM_ERD);
	}
}

static void mpsc_stop_rx(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;

	pr_debug("mpsc_stop_rx[%d]: Stopping...\n", port->line);

	if (pi->mirror_regs) {
		writel(pi->MPSC_CHR_2_m | MPSC_CHR_2_RA,
				pi->mpsc_base + MPSC_CHR_2);
		/* Erratum prevents reading CHR_2 so just delay for a while */
		udelay(100);
	} else {
		writel(readl(pi->mpsc_base + MPSC_CHR_2) | MPSC_CHR_2_RA,
				pi->mpsc_base + MPSC_CHR_2);

		while (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_RA)
			udelay(10);
	}

	mpsc_sdma_cmd(pi, SDMA_SDCM_AR);
}

static void mpsc_enable_ms(struct uart_port *port)
{
}

static void mpsc_break_ctl(struct uart_port *port, int ctl)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	ulong	flags;
	u32	v;

	v = ctl ? 0x00ff0000 : 0;

	spin_lock_irqsave(&pi->port.lock, flags);
	if (pi->mirror_regs)
		pi->MPSC_CHR_1_m = v;
	writel(v, pi->mpsc_base + MPSC_CHR_1);
	spin_unlock_irqrestore(&pi->port.lock, flags);
}

static int mpsc_startup(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	u32 flag = 0;
	int rc;

	pr_debug("mpsc_startup[%d]: Starting up MPSC, irq: %d\n",
		port->line, pi->port.irq);

	if ((rc = mpsc_make_ready(pi)) == 0) {
		/* Setup IRQ handler */
		mpsc_sdma_intr_ack(pi);

		/* If irq's are shared, need to set flag */
		if (mpsc_ports[0].port.irq == mpsc_ports[1].port.irq)
			flag = IRQF_SHARED;

		if (request_irq(pi->port.irq, mpsc_sdma_intr, flag,
					"mpsc-sdma", pi))
			printk(KERN_ERR "MPSC: Can't get SDMA IRQ %d\n",
					pi->port.irq);

		mpsc_sdma_intr_unmask(pi, 0xf);
		mpsc_sdma_set_rx_ring(pi, (struct mpsc_rx_desc *)(pi->rxr_p
					+ (pi->rxr_posn * MPSC_RXRE_SIZE)));
	}

	return rc;
}

static void mpsc_shutdown(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;

	pr_debug("mpsc_shutdown[%d]: Shutting down MPSC\n", port->line);

	mpsc_sdma_stop(pi);
	free_irq(pi->port.irq, pi);
}

static void mpsc_set_termios(struct uart_port *port, struct ktermios *termios,
		 struct ktermios *old)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	u32 baud;
	ulong flags;
	u32 chr_bits, stop_bits, par;

	pi->c_iflag = termios->c_iflag;
	pi->c_cflag = termios->c_cflag;

	switch (termios->c_cflag & CSIZE) {
	case CS5:
		chr_bits = MPSC_MPCR_CL_5;
		break;
	case CS6:
		chr_bits = MPSC_MPCR_CL_6;
		break;
	case CS7:
		chr_bits = MPSC_MPCR_CL_7;
		break;
	case CS8:
	default:
		chr_bits = MPSC_MPCR_CL_8;
		break;
	}

	if (termios->c_cflag & CSTOPB)
		stop_bits = MPSC_MPCR_SBL_2;
	else
		stop_bits = MPSC_MPCR_SBL_1;

	par = MPSC_CHR_2_PAR_EVEN;
	if (termios->c_cflag & PARENB)
		if (termios->c_cflag & PARODD)
			par = MPSC_CHR_2_PAR_ODD;
#ifdef	CMSPAR
		if (termios->c_cflag & CMSPAR) {
			if (termios->c_cflag & PARODD)
				par = MPSC_CHR_2_PAR_MARK;
			else
				par = MPSC_CHR_2_PAR_SPACE;
		}
#endif

	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk);

	spin_lock_irqsave(&pi->port.lock, flags);

	uart_update_timeout(port, termios->c_cflag, baud);

	mpsc_set_char_length(pi, chr_bits);
	mpsc_set_stop_bit_length(pi, stop_bits);
	mpsc_set_parity(pi, par);
	mpsc_set_baudrate(pi, baud);

	/* Characters/events to read */
	pi->port.read_status_mask = SDMA_DESC_CMDSTAT_OR;

	if (termios->c_iflag & INPCK)
		pi->port.read_status_mask |= SDMA_DESC_CMDSTAT_PE
			| SDMA_DESC_CMDSTAT_FR;

	if (termios->c_iflag & (BRKINT | PARMRK))
		pi->port.read_status_mask |= SDMA_DESC_CMDSTAT_BR;

	/* Characters/events to ignore */
	pi->port.ignore_status_mask = 0;

	if (termios->c_iflag & IGNPAR)
		pi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_PE
			| SDMA_DESC_CMDSTAT_FR;

	if (termios->c_iflag & IGNBRK) {
		pi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_BR;

		if (termios->c_iflag & IGNPAR)
			pi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_OR;
	}

	if ((termios->c_cflag & CREAD)) {
		if (!pi->rcv_data) {
			pi->rcv_data = 1;
			mpsc_start_rx(pi);
		}
	} else if (pi->rcv_data) {
		mpsc_stop_rx(port);
		pi->rcv_data = 0;
	}

	spin_unlock_irqrestore(&pi->port.lock, flags);
}

static const char *mpsc_type(struct uart_port *port)
{
	pr_debug("mpsc_type[%d]: port type: %s\n", port->line,MPSC_DRIVER_NAME);
	return MPSC_DRIVER_NAME;
}

static int mpsc_request_port(struct uart_port *port)
{
	/* Should make chip/platform specific call */
	return 0;
}

static void mpsc_release_port(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;

	if (pi->ready) {
		mpsc_uninit_rings(pi);
		mpsc_free_ring_mem(pi);
		pi->ready = 0;
	}
}

static void mpsc_config_port(struct uart_port *port, int flags)
{
}

static int mpsc_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	int rc = 0;

	pr_debug("mpsc_verify_port[%d]: Verifying port data\n", pi->port.line);

	if (ser->type != PORT_UNKNOWN && ser->type != PORT_MPSC)
		rc = -EINVAL;
	else if (pi->port.irq != ser->irq)
		rc = -EINVAL;
	else if (ser->io_type != SERIAL_IO_MEM)
		rc = -EINVAL;
	else if (pi->port.uartclk / 16 != ser->baud_base) /* Not sure */
		rc = -EINVAL;
	else if ((void *)pi->port.mapbase != ser->iomem_base)
		rc = -EINVAL;
	else if (pi->port.iobase != ser->port)
		rc = -EINVAL;
	else if (ser->hub6 != 0)
		rc = -EINVAL;

	return rc;
}
#ifdef CONFIG_CONSOLE_POLL
/* Serial polling routines for writing and reading from the uart while
 * in an interrupt or debug context.
 */

static char poll_buf[2048];
static int poll_ptr;
static int poll_cnt;
static void mpsc_put_poll_char(struct uart_port *port,
							   unsigned char c);

static int mpsc_get_poll_char(struct uart_port *port)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	struct mpsc_rx_desc *rxre;
	u32	cmdstat, bytes_in, i;
	u8	*bp;

	if (!serial_polled)
		serial_polled = 1;

	pr_debug("mpsc_rx_intr[%d]: Handling Rx intr\n", pi->port.line);

	if (poll_cnt) {
		poll_cnt--;
		return poll_buf[poll_ptr++];
	}
	poll_ptr = 0;
	poll_cnt = 0;

	while (poll_cnt == 0) {
		rxre = (struct mpsc_rx_desc *)(pi->rxr +
		       (pi->rxr_posn*MPSC_RXRE_SIZE));
		dma_cache_sync(pi->port.dev, (void *)rxre,
			       MPSC_RXRE_SIZE, DMA_FROM_DEVICE);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
			invalidate_dcache_range((ulong)rxre,
			(ulong)rxre + MPSC_RXRE_SIZE);
#endif
		/*
		 * Loop through Rx descriptors handling ones that have
		 * been completed.
		 */
		while (poll_cnt == 0 &&
		       !((cmdstat = be32_to_cpu(rxre->cmdstat)) &
			 SDMA_DESC_CMDSTAT_O)){
			bytes_in = be16_to_cpu(rxre->bytecnt);
			bp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);
			dma_cache_sync(pi->port.dev, (void *) bp,
				       MPSC_RXBE_SIZE, DMA_FROM_DEVICE);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
			if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
				invalidate_dcache_range((ulong)bp,
					(ulong)bp + MPSC_RXBE_SIZE);
#endif
			if ((unlikely(cmdstat & (SDMA_DESC_CMDSTAT_BR |
			 SDMA_DESC_CMDSTAT_FR | SDMA_DESC_CMDSTAT_OR))) &&
				!(cmdstat & pi->port.ignore_status_mask)) {
				poll_buf[poll_cnt] = *bp;
				poll_cnt++;
			} else {
				for (i = 0; i < bytes_in; i++) {
					poll_buf[poll_cnt] = *bp++;
					poll_cnt++;
				}
				pi->port.icount.rx += bytes_in;
			}
			rxre->bytecnt = cpu_to_be16(0);
			wmb();
			rxre->cmdstat = cpu_to_be32(SDMA_DESC_CMDSTAT_O |
						    SDMA_DESC_CMDSTAT_EI |
						    SDMA_DESC_CMDSTAT_F |
						    SDMA_DESC_CMDSTAT_L);
			wmb();
			dma_cache_sync(pi->port.dev, (void *)rxre,
				       MPSC_RXRE_SIZE, DMA_BIDIRECTIONAL);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
			if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
				flush_dcache_range((ulong)rxre,
					   (ulong)rxre + MPSC_RXRE_SIZE);
#endif

			/* Advance to next descriptor */
			pi->rxr_posn = (pi->rxr_posn + 1) &
				(MPSC_RXR_ENTRIES - 1);
			rxre = (struct mpsc_rx_desc *)(pi->rxr +
				       (pi->rxr_posn * MPSC_RXRE_SIZE));
			dma_cache_sync(pi->port.dev, (void *)rxre,
				       MPSC_RXRE_SIZE, DMA_FROM_DEVICE);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
			if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
				invalidate_dcache_range((ulong)rxre,
						(ulong)rxre + MPSC_RXRE_SIZE);
#endif
		}

		/* Restart rx engine, if its stopped */
		if ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)
			mpsc_start_rx(pi);
	}
	if (poll_cnt) {
		poll_cnt--;
		return poll_buf[poll_ptr++];
	}

	return 0;
}


static void mpsc_put_poll_char(struct uart_port *port,
			 unsigned char c)
{
	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
	u32 data;

	data = readl(pi->mpsc_base + MPSC_MPCR);
	writeb(c, pi->mpsc_base + MPSC_CHR_1);
	mb();
	data = readl(pi->mpsc_base + MPSC_CHR_2);
	data |= MPSC_CHR_2_TTCS;
	writel(data, pi->mpsc_base + MPSC_CHR_2);
	mb();

	while (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_TTCS);
}
#endif

static struct uart_ops mpsc_pops = {
	.tx_empty	= mpsc_tx_empty,
	.set_mctrl	= mpsc_set_mctrl,
	.get_mctrl	= mpsc_get_mctrl,
	.stop_tx	= mpsc_stop_tx,
	.start_tx	= mpsc_start_tx,
	.stop_rx	= mpsc_stop_rx,
	.enable_ms	= mpsc_enable_ms,
	.break_ctl	= mpsc_break_ctl,
	.startup	= mpsc_startup,
	.shutdown	= mpsc_shutdown,
	.set_termios	= mpsc_set_termios,
	.type		= mpsc_type,
	.release_port	= mpsc_release_port,
	.request_port	= mpsc_request_port,
	.config_port	= mpsc_config_port,
	.verify_port	= mpsc_verify_port,
#ifdef CONFIG_CONSOLE_POLL
	.poll_get_char = mpsc_get_poll_char,
	.poll_put_char = mpsc_put_poll_char,
#endif
};

/*
 ******************************************************************************
 *
 * Console Interface Routines
 *
 ******************************************************************************
 */

#ifdef CONFIG_SERIAL_MPSC_CONSOLE
static void mpsc_console_write(struct console *co, const char *s, uint count)
{
	struct mpsc_port_info *pi = &mpsc_ports[co->index];
	u8 *bp, *dp, add_cr = 0;
	int i;
	unsigned long iflags;

	spin_lock_irqsave(&pi->tx_lock, iflags);

	while (pi->txr_head != pi->txr_tail) {
		while (mpsc_sdma_tx_active(pi))
			udelay(100);
		mpsc_sdma_intr_ack(pi);
		mpsc_tx_intr(pi);
	}

	while (mpsc_sdma_tx_active(pi))
		udelay(100);

	while (count > 0) {
		bp = dp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);

		for (i = 0; i < MPSC_TXBE_SIZE; i++) {
			if (count == 0)
				break;

			if (add_cr) {
				*(dp++) = '\r';
				add_cr = 0;
			} else {
				*(dp++) = *s;

				if (*(s++) == '\n') { /* add '\r' after '\n' */
					add_cr = 1;
					count++;
				}
			}

			count--;
		}

		dma_cache_sync(pi->port.dev, (void *)bp, MPSC_TXBE_SIZE,
				DMA_BIDIRECTIONAL);
#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
			flush_dcache_range((ulong)bp,
					(ulong)bp + MPSC_TXBE_SIZE);
#endif
		mpsc_setup_tx_desc(pi, i, 0);
		pi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);
		mpsc_sdma_start_tx(pi);

		while (mpsc_sdma_tx_active(pi))
			udelay(100);

		pi->txr_tail = (pi->txr_tail + 1) & (MPSC_TXR_ENTRIES - 1);
	}

	spin_unlock_irqrestore(&pi->tx_lock, iflags);
}

static int __init mpsc_console_setup(struct console *co, char *options)
{
	struct mpsc_port_info *pi;
	int baud, bits, parity, flow;

	pr_debug("mpsc_console_setup[%d]: options: %s\n", co->index, options);

	if (co->index >= MPSC_NUM_CTLRS)
		co->index = 0;

	pi = &mpsc_ports[co->index];

	baud = pi->default_baud;
	bits = pi->default_bits;
	parity = pi->default_parity;
	flow = pi->default_flow;

	if (!pi->port.ops)
		return -ENODEV;

	spin_lock_init(&pi->port.lock);	/* Temporary fix--copied from 8250.c */

	if (options)
		uart_parse_options(options, &baud, &parity, &bits, &flow);

	return uart_set_options(&pi->port, co, baud, parity, bits, flow);
}

static struct console mpsc_console = {
	.name	= MPSC_DEV_NAME,
	.write	= mpsc_console_write,
	.device	= uart_console_device,
	.setup	= mpsc_console_setup,
	.flags	= CON_PRINTBUFFER,
	.index	= -1,
	.data	= &mpsc_reg,
};

static int __init mpsc_late_console_init(void)
{
	pr_debug("mpsc_late_console_init: Enter\n");

	if (!(mpsc_console.flags & CON_ENABLED))
		register_console(&mpsc_console);
	return 0;
}

late_initcall(mpsc_late_console_init);

#define MPSC_CONSOLE	&mpsc_console
#else
#define MPSC_CONSOLE	NULL
#endif
/*
 ******************************************************************************
 *
 * Dummy Platform Driver to extract & map shared register regions
 *
 ******************************************************************************
 */
static void mpsc_resource_err(char *s)
{
	printk(KERN_WARNING "MPSC: Platform device resource error in %s\n", s);
}

static int mpsc_shared_map_regs(struct platform_device *pd)
{
	struct resource	*r;

	if ((r = platform_get_resource(pd, IORESOURCE_MEM,
					MPSC_ROUTING_BASE_ORDER))
			&& request_mem_region(r->start,
				MPSC_ROUTING_REG_BLOCK_SIZE,
				"mpsc_routing_regs")) {
		mpsc_shared_regs.mpsc_routing_base = ioremap(r->start,
				MPSC_ROUTING_REG_BLOCK_SIZE);
		mpsc_shared_regs.mpsc_routing_base_p = r->start;
	} else {
		mpsc_resource_err("MPSC routing base");
		return -ENOMEM;
	}

	if ((r = platform_get_resource(pd, IORESOURCE_MEM,
					MPSC_SDMA_INTR_BASE_ORDER))
			&& request_mem_region(r->start,
				MPSC_SDMA_INTR_REG_BLOCK_SIZE,
				"sdma_intr_regs")) {
		mpsc_shared_regs.sdma_intr_base = ioremap(r->start,
			MPSC_SDMA_INTR_REG_BLOCK_SIZE);
		mpsc_shared_regs.sdma_intr_base_p = r->start;
	} else {
		iounmap(mpsc_shared_regs.mpsc_routing_base);
		release_mem_region(mpsc_shared_regs.mpsc_routing_base_p,
				MPSC_ROUTING_REG_BLOCK_SIZE);
		mpsc_resource_err("SDMA intr base");
		return -ENOMEM;
	}

	return 0;
}

static void mpsc_shared_unmap_regs(void)
{
	if (!mpsc_shared_regs.mpsc_routing_base) {
		iounmap(mpsc_shared_regs.mpsc_routing_base);
		release_mem_region(mpsc_shared_regs.mpsc_routing_base_p,
				MPSC_ROUTING_REG_BLOCK_SIZE);
	}
	if (!mpsc_shared_regs.sdma_intr_base) {
		iounmap(mpsc_shared_regs.sdma_intr_base);
		release_mem_region(mpsc_shared_regs.sdma_intr_base_p,
				MPSC_SDMA_INTR_REG_BLOCK_SIZE);
	}

	mpsc_shared_regs.mpsc_routing_base = NULL;
	mpsc_shared_regs.sdma_intr_base = NULL;

	mpsc_shared_regs.mpsc_routing_base_p = 0;
	mpsc_shared_regs.sdma_intr_base_p = 0;
}

static int mpsc_shared_drv_probe(struct platform_device *dev)
{
	struct mpsc_shared_pdata	*pdata;
	int				 rc = -ENODEV;

	if (dev->id == 0) {
		if (!(rc = mpsc_shared_map_regs(dev))) {
			pdata = (struct mpsc_shared_pdata *)
				dev->dev.platform_data;

			mpsc_shared_regs.MPSC_MRR_m = pdata->mrr_val;
			mpsc_shared_regs.MPSC_RCRR_m= pdata->rcrr_val;
			mpsc_shared_regs.MPSC_TCRR_m= pdata->tcrr_val;
			mpsc_shared_regs.SDMA_INTR_CAUSE_m =
				pdata->intr_cause_val;
			mpsc_shared_regs.SDMA_INTR_MASK_m =
				pdata->intr_mask_val;

			rc = 0;
		}
	}

	return rc;
}

static int mpsc_shared_drv_remove(struct platform_device *dev)
{
	int	rc = -ENODEV;

	if (dev->id == 0) {
		mpsc_shared_unmap_regs();
		mpsc_shared_regs.MPSC_MRR_m = 0;
		mpsc_shared_regs.MPSC_RCRR_m = 0;
		mpsc_shared_regs.MPSC_TCRR_m = 0;
		mpsc_shared_regs.SDMA_INTR_CAUSE_m = 0;
		mpsc_shared_regs.SDMA_INTR_MASK_m = 0;
		rc = 0;
	}

	return rc;
}

static struct platform_driver mpsc_shared_driver = {
	.probe	= mpsc_shared_drv_probe,
	.remove	= mpsc_shared_drv_remove,
	.driver	= {
		.name	= MPSC_SHARED_NAME,
	},
};

/*
 ******************************************************************************
 *
 * Driver Interface Routines
 *
 ******************************************************************************
 */
static struct uart_driver mpsc_reg = {
	.owner		= THIS_MODULE,
	.driver_name	= MPSC_DRIVER_NAME,
	.dev_name	= MPSC_DEV_NAME,
	.major		= MPSC_MAJOR,
	.minor		= MPSC_MINOR_START,
	.nr		= MPSC_NUM_CTLRS,
	.cons		= MPSC_CONSOLE,
};

static int mpsc_drv_map_regs(struct mpsc_port_info *pi,
		struct platform_device *pd)
{
	struct resource	*r;

	if ((r = platform_get_resource(pd, IORESOURCE_MEM, MPSC_BASE_ORDER))
			&& request_mem_region(r->start, MPSC_REG_BLOCK_SIZE,
			"mpsc_regs")) {
		pi->mpsc_base = ioremap(r->start, MPSC_REG_BLOCK_SIZE);
		pi->mpsc_base_p = r->start;
	} else {
		mpsc_resource_err("MPSC base");
		goto err;
	}

	if ((r = platform_get_resource(pd, IORESOURCE_MEM,
					MPSC_SDMA_BASE_ORDER))
			&& request_mem_region(r->start,
				MPSC_SDMA_REG_BLOCK_SIZE, "sdma_regs")) {
		pi->sdma_base = ioremap(r->start,MPSC_SDMA_REG_BLOCK_SIZE);
		pi->sdma_base_p = r->start;
	} else {
		mpsc_resource_err("SDMA base");
		if (pi->mpsc_base) {
			iounmap(pi->mpsc_base);
			pi->mpsc_base = NULL;
		}
		goto err;
	}

	if ((r = platform_get_resource(pd,IORESOURCE_MEM,MPSC_BRG_BASE_ORDER))
			&& request_mem_region(r->start,
				MPSC_BRG_REG_BLOCK_SIZE, "brg_regs")) {
		pi->brg_base = ioremap(r->start, MPSC_BRG_REG_BLOCK_SIZE);
		pi->brg_base_p = r->start;
	} else {
		mpsc_resource_err("BRG base");
		if (pi->mpsc_base) {
			iounmap(pi->mpsc_base);
			pi->mpsc_base = NULL;
		}
		if (pi->sdma_base) {
			iounmap(pi->sdma_base);
			pi->sdma_base = NULL;
		}
		goto err;
	}
	return 0;

err:
	return -ENOMEM;
}

static void mpsc_drv_unmap_regs(struct mpsc_port_info *pi)
{
	if (!pi->mpsc_base) {
		iounmap(pi->mpsc_base);
		release_mem_region(pi->mpsc_base_p, MPSC_REG_BLOCK_SIZE);
	}
	if (!pi->sdma_base) {
		iounmap(pi->sdma_base);
		release_mem_region(pi->sdma_base_p, MPSC_SDMA_REG_BLOCK_SIZE);
	}
	if (!pi->brg_base) {
		iounmap(pi->brg_base);
		release_mem_region(pi->brg_base_p, MPSC_BRG_REG_BLOCK_SIZE);
	}

	pi->mpsc_base = NULL;
	pi->sdma_base = NULL;
	pi->brg_base = NULL;

	pi->mpsc_base_p = 0;
	pi->sdma_base_p = 0;
	pi->brg_base_p = 0;
}

static void mpsc_drv_get_platform_data(struct mpsc_port_info *pi,
		struct platform_device *pd, int num)
{
	struct mpsc_pdata	*pdata;

	pdata = (struct mpsc_pdata *)pd->dev.platform_data;

	pi->port.uartclk = pdata->brg_clk_freq;
	pi->port.iotype = UPIO_MEM;
	pi->port.line = num;
	pi->port.type = PORT_MPSC;
	pi->port.fifosize = MPSC_TXBE_SIZE;
	pi->port.membase = pi->mpsc_base;
	pi->port.mapbase = (ulong)pi->mpsc_base;
	pi->port.ops = &mpsc_pops;

	pi->mirror_regs = pdata->mirror_regs;
	pi->cache_mgmt = pdata->cache_mgmt;
	pi->brg_can_tune = pdata->brg_can_tune;
	pi->brg_clk_src = pdata->brg_clk_src;
	pi->mpsc_max_idle = pdata->max_idle;
	pi->default_baud = pdata->default_baud;
	pi->default_bits = pdata->default_bits;
	pi->default_parity = pdata->default_parity;
	pi->default_flow = pdata->default_flow;

	/* Initial values of mirrored regs */
	pi->MPSC_CHR_1_m = pdata->chr_1_val;
	pi->MPSC_CHR_2_m = pdata->chr_2_val;
	pi->MPSC_CHR_10_m = pdata->chr_10_val;
	pi->MPSC_MPCR_m = pdata->mpcr_val;
	pi->BRG_BCR_m = pdata->bcr_val;

	pi->shared_regs = &mpsc_shared_regs;

	pi->port.irq = platform_get_irq(pd, 0);
}

static int mpsc_drv_probe(struct platform_device *dev)
{
	struct mpsc_port_info	*pi;
	int			rc = -ENODEV;

	pr_debug("mpsc_drv_probe: Adding MPSC %d\n", dev->id);

	if (dev->id < MPSC_NUM_CTLRS) {
		pi = &mpsc_ports[dev->id];

		if (!(rc = mpsc_drv_map_regs(pi, dev))) {
			mpsc_drv_get_platform_data(pi, dev, dev->id);

			if (!(rc = mpsc_make_ready(pi))) {
				spin_lock_init(&pi->tx_lock);
				if (!(rc = uart_add_one_port(&mpsc_reg,
								&pi->port))) {
					rc = 0;
				} else {
					mpsc_release_port((struct uart_port *)
							pi);
					mpsc_drv_unmap_regs(pi);
				}
			} else {
				mpsc_drv_unmap_regs(pi);
			}
		}
	}

	return rc;
}

static int mpsc_drv_remove(struct platform_device *dev)
{
	pr_debug("mpsc_drv_exit: Removing MPSC %d\n", dev->id);

	if (dev->id < MPSC_NUM_CTLRS) {
		uart_remove_one_port(&mpsc_reg, &mpsc_ports[dev->id].port);
		mpsc_release_port((struct uart_port *)
				&mpsc_ports[dev->id].port);
		mpsc_drv_unmap_regs(&mpsc_ports[dev->id]);
		return 0;
	} else {
		return -ENODEV;
	}
}

static struct platform_driver mpsc_driver = {
	.probe	= mpsc_drv_probe,
	.remove	= mpsc_drv_remove,
	.driver	= {
		.name	= MPSC_CTLR_NAME,
		.owner	= THIS_MODULE,
	},
};

static int __init mpsc_drv_init(void)
{
	int	rc;

	printk(KERN_INFO "Serial: MPSC driver\n");

	memset(mpsc_ports, 0, sizeof(mpsc_ports));
	memset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));

	if (!(rc = uart_register_driver(&mpsc_reg))) {
		if (!(rc = platform_driver_register(&mpsc_shared_driver))) {
			if ((rc = platform_driver_register(&mpsc_driver))) {
				platform_driver_unregister(&mpsc_shared_driver);
				uart_unregister_driver(&mpsc_reg);
			}
		} else {
			uart_unregister_driver(&mpsc_reg);
		}
	}

	return rc;
}

static void __exit mpsc_drv_exit(void)
{
	platform_driver_unregister(&mpsc_driver);
	platform_driver_unregister(&mpsc_shared_driver);
	uart_unregister_driver(&mpsc_reg);
	memset(mpsc_ports, 0, sizeof(mpsc_ports));
	memset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));
}

module_init(mpsc_drv_init);
module_exit(mpsc_drv_exit);

MODULE_AUTHOR("Mark A. Greer <mgreer@mvista.com>");
MODULE_DESCRIPTION("Generic Marvell MPSC serial/UART driver");
MODULE_VERSION(MPSC_VERSION);
MODULE_LICENSE("GPL");
MODULE_ALIAS_CHARDEV_MAJOR(MPSC_MAJOR);
MODULE_ALIAS("platform:" MPSC_CTLR_NAME);
                                                                                                                                                                                                                                                                                                                                           @          Ô         
   *                  .dynsym .dynstr .hash .rodata .text .dynamic .oat_patches .shstrtab                                                     Ô   Ô   @                	             *                          @  @                                                                     Ä                 %          0   0  8                .      €        80                    ;              80  E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       